{"version":3,"sources":["Algorithms/algorithms.js","PathFindingVisualizer/Node/Node.js","PathFindingVisualizer/PathFindingVisualizer.js","App.js","index.js"],"names":["sortNodesByDistance","unvisitedNodes","isDijkstra","sort","nodeA","nodeB","distance","heuristic","updateUnvisitedNeighbors","node","grid","isBFS","unvisitedNeighbors","getUnvisitedNeighbors","neighbor","isWeight","previousNode","neighbors","col","row","push","length","filter","isVisited","getAllNodes","nodes","getNodesInShortestPathOrder","finishNode","nodesInShortestPathOrder","currentNode","unshift","recursiveDivisionMaze","rowStart","rowEnd","colStart","colEnd","orientation","divisionWalls","possibleRows","number","possibleCols","randomRowIndex","Math","floor","random","randomColIndex","currentRow","colRandom","i","currentCol","rowRandom","Node","this","props","isStart","isFinish","isWall","onMouseDown","onMouseEnter","onMouseUp","nodeSize","extraClassName","id","className","style","width","height","Component","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","PathfindingVisualizer","state","mouseIsPressed","startIsSelected","finishIsSelected","window","outerWidth","getInitialGrid","setState","location","reload","newGrid","Infinity","document","getElementById","checked","getNewGridWithWallToggled","getNewGridWithWeightToggled","getNewGridWithFinishToggled","getNewGridWithStartToggled","setTimeout","body","pointerEvents","opacity","visitedNodesInOrder","animateShortestPath","clearPath","startNode","sqrt","pow","abs","closestNode","shift","dijkstraANDastar","animateDijkstra","nodeCount","latestNode","depthFirstSearch","animateDFS","clearWeights","items","getElementsByClassName","display","j","k","l","color","backgroundColor","class","onClick","visualizeDijkstraOrAstar","border","visualizeDFS","clearBoard","type","name","generateMaze","alignItems","position","map","rowIdx","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","fontSize","marginTop","marginLeft","href","createNode","slice","newNode","previousStart","change","previousFinish","App","ReactDom","render","querySelector"],"mappings":"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","file":"static/js/main.5e0b3c09.chunk.js","sourcesContent":["//Dijkstra and A*\r\nexport function dijkstraANDastar(grid, startNode, finishNode, isDijkstra, isBFS) {\r\n    for (const row of grid) {\r\n        for (const node of row) {\r\n            node.heuristic = Math.floor(Math.sqrt(Math.pow(Math.abs(node.row - finishNode.row), 2) + Math.pow(Math.abs(node.col - finishNode.col), 2)))\r\n        }\r\n    }\r\n    const visitedNodesInOrder = [];\r\n    startNode.distance = 0;\r\n    const unvisitedNodes = getAllNodes(grid);\r\n    while (!!unvisitedNodes.length) {\r\n        sortNodesByDistance(unvisitedNodes, isDijkstra);\r\n        const closestNode = unvisitedNodes.shift();\r\n        if (closestNode.isWall) continue;\r\n        if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n        closestNode.isVisited = true;\r\n        visitedNodesInOrder.push(closestNode);\r\n        if (closestNode === finishNode) return visitedNodesInOrder;\r\n        updateUnvisitedNeighbors(closestNode, grid, isBFS);\r\n    }\r\n}\r\n\r\n//Depth First Search\r\nexport function depthFirstSearch(grid, startNode, finishNode) {\r\n    const visitedNodesInOrder = [];\r\n    startNode.distance = 0;\r\n    startNode.isVisited = true;\r\n    const unvisitedNodes = getAllNodes(grid);\r\n    sortNodesByDistance(unvisitedNodes, true);\r\n    visitedNodesInOrder.push(unvisitedNodes.shift());\r\n    let nodeCount = unvisitedNodes.length;\r\n    let currentNode = visitedNodesInOrder[visitedNodesInOrder.length - 1];\r\n    let neighbors = getUnvisitedNeighbors(currentNode, grid);\r\n    while (nodeCount--) {\r\n        neighbors = neighbors.filter(neighbor => !neighbor.isWall);\r\n        if (neighbors.length) {\r\n            const latestNode = neighbors.shift();\r\n            latestNode.isVisited = true;\r\n            latestNode.previousNode = currentNode;\r\n            visitedNodesInOrder.push(latestNode);\r\n            if (latestNode === finishNode) {\r\n                return visitedNodesInOrder;\r\n            }\r\n            currentNode = visitedNodesInOrder[visitedNodesInOrder.length - 1];\r\n            neighbors = getUnvisitedNeighbors(currentNode, grid);\r\n        }\r\n        else {\r\n            while (neighbors.length === 0) {\r\n                currentNode = currentNode.previousNode;\r\n                if (currentNode === null)\r\n                    return visitedNodesInOrder;\r\n                neighbors = getUnvisitedNeighbors(currentNode, grid);\r\n            }\r\n        }\r\n    }\r\n    return visitedNodesInOrder;\r\n}\r\n\r\n//utility functions\r\nfunction sortNodesByDistance(unvisitedNodes, isDijkstra) {\r\n    if (isDijkstra)\r\n        unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n    else\r\n        unvisitedNodes.sort((nodeA, nodeB) => (nodeA.distance + nodeA.heuristic) - (nodeB.distance + nodeB.heuristic));\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid, isBFS) {\r\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n    for (const neighbor of unvisitedNeighbors) {\r\n        if (isBFS || !neighbor.isWeight)\r\n            neighbor.distance = node.distance + 1;\r\n        else\r\n            neighbor.distance = node.distance + 5;\r\n        neighbor.previousNode = node;\r\n    }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const { col, row } = node;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n    const nodes = [];\r\n    for (const row of grid) {\r\n        for (const node of row) {\r\n            nodes.push(node);\r\n        }\r\n    }\r\n    return nodes;\r\n}\r\n\r\n//backtrack and return path\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n        nodesInShortestPathOrder.unshift(currentNode);\r\n        currentNode = currentNode.previousNode;\r\n    }\r\n    return nodesInShortestPathOrder;\r\n}\r\n\r\n//mazeGenerator\r\nexport function recursiveDivisionMaze(rowStart, rowEnd, colStart, colEnd, orientation, divisionWalls) {\r\n    if (rowEnd < rowStart || colEnd < colStart) {\r\n        return;\r\n    }\r\n\r\n    if (orientation === 0) {\r\n        let possibleRows = [];\r\n        for (let number = rowStart; number <= rowEnd; number += 2) {\r\n            possibleRows.push(number);\r\n        }\r\n        let possibleCols = [];\r\n        for (let number = colStart - 1; number <= colEnd + 1; number += 2) {\r\n            possibleCols.push(number);\r\n        }\r\n        let randomRowIndex = Math.floor(Math.random() * possibleRows.length);\r\n        let randomColIndex = Math.floor(Math.random() * possibleCols.length);\r\n        let currentRow = possibleRows[randomRowIndex];\r\n        let colRandom = possibleCols[randomColIndex];\r\n        for (let i = colStart - 1; i <= colEnd + 1; i++) {\r\n            if (i === colRandom)\r\n                continue;\r\n            divisionWalls.push([currentRow, i]);\r\n        }\r\n        if (currentRow - 2 - rowStart > colEnd - colStart) {\r\n            recursiveDivisionMaze(rowStart, currentRow - 2, colStart, colEnd, orientation, divisionWalls);\r\n        } else {\r\n            recursiveDivisionMaze(rowStart, currentRow - 2, colStart, colEnd, 1, divisionWalls);\r\n        }\r\n        if (rowEnd - (currentRow + 2) > colEnd - colStart) {\r\n            recursiveDivisionMaze(currentRow + 2, rowEnd, colStart, colEnd, orientation, divisionWalls);\r\n        } else {\r\n            recursiveDivisionMaze(currentRow + 2, rowEnd, colStart, colEnd, 1, divisionWalls);\r\n        }\r\n    } else {\r\n        let possibleCols = [];\r\n        for (let number = colStart; number <= colEnd; number += 2) {\r\n            possibleCols.push(number);\r\n        }\r\n        let possibleRows = [];\r\n        for (let number = rowStart - 1; number <= rowEnd + 1; number += 2) {\r\n            possibleRows.push(number);\r\n        }\r\n        let randomColIndex = Math.floor(Math.random() * possibleCols.length);\r\n        let randomRowIndex = Math.floor(Math.random() * possibleRows.length);\r\n        let currentCol = possibleCols[randomColIndex];\r\n        let rowRandom = possibleRows[randomRowIndex];\r\n        for (let i = rowStart - 1; i <= rowEnd + 1; i++) {\r\n            if (i === rowRandom)\r\n                continue;\r\n            divisionWalls.push([i, currentCol]);\r\n        }\r\n        if (rowEnd - rowStart > currentCol - 2 - colStart) {\r\n            recursiveDivisionMaze(rowStart, rowEnd, colStart, currentCol - 2, 0, divisionWalls);\r\n        } else {\r\n            recursiveDivisionMaze(rowStart, rowEnd, colStart, currentCol - 2, orientation, divisionWalls);\r\n        }\r\n        if (rowEnd - rowStart > colEnd - (currentCol + 2)) {\r\n            recursiveDivisionMaze(rowStart, rowEnd, currentCol + 2, colEnd, 0, divisionWalls);\r\n        } else {\r\n            recursiveDivisionMaze(rowStart, rowEnd, currentCol + 2, colEnd, orientation, divisionWalls);\r\n        }\r\n    }\r\n}","import React, { Component } from 'react';\r\nimport \"./Node.css\"\r\n\r\nexport default class Node extends Component {\r\n    render() {\r\n        const {\r\n            row,\r\n            col,\r\n            isStart,\r\n            isFinish,\r\n            isWall,\r\n            isWeight,\r\n            onMouseDown,\r\n            onMouseEnter,\r\n            onMouseUp,\r\n            nodeSize\r\n        } = this.props;\r\n        const extraClassName = isFinish\r\n            ? 'node-finish'\r\n            : isStart\r\n                ? 'node-start'\r\n                : isWall\r\n                    ? 'node-wall'\r\n                    : isWeight\r\n                        ? 'node-weight'\r\n                        : '';\r\n\r\n        return (\r\n            <td id={`node-${row}-${col}`}\r\n                className={extraClassName}\r\n                onMouseDown={() => onMouseDown(row, col)}\r\n                onMouseEnter={() => onMouseEnter(row, col)}\r\n                onMouseUp={() => onMouseUp(row, col)}\r\n                style={{ width: `${nodeSize}px`, height: `${nodeSize}px` }}>\r\n            </td>\r\n        );\r\n    }\r\n}","import React, { Component } from 'react';\r\nimport { dijkstraANDastar, depthFirstSearch, getNodesInShortestPathOrder, recursiveDivisionMaze } from '../Algorithms/algorithms';\r\nimport Node from './Node/Node';\r\nimport \"./PathFindingVisualizer.css\";\r\n\r\nlet START_NODE_ROW = 10;\r\nlet START_NODE_COL = 15;\r\nlet FINISH_NODE_ROW = 10;\r\nlet FINISH_NODE_COL = 35;\r\n\r\nexport default class PathfindingVisualizer extends Component {\r\n    constructor() {\r\n        super();\r\n        this.state = {\r\n            grid: [],\r\n            mouseIsPressed: false,\r\n            startIsSelected: false,\r\n            finishIsSelected: false,\r\n            nodeSize: (window.outerWidth - 20) / 50\r\n        };\r\n    }\r\n\r\n    componentDidMount() {\r\n        const grid = getInitialGrid();\r\n        this.setState({ grid });\r\n    }\r\n\r\n    clearBoard() {\r\n        window.location.reload();\r\n    }\r\n\r\n    clearWeights() {\r\n        const newGrid = this.state.grid;\r\n        for (let row of newGrid) {\r\n            for (let node of row) {\r\n                node.isStart = node.row === START_NODE_ROW && node.col === START_NODE_COL;\r\n                node.isFinish = node.row === FINISH_NODE_ROW && node.col === FINISH_NODE_COL;\r\n                node.distance = Infinity;\r\n                node.heuristic = 0;\r\n                node.isVisited = false;\r\n                node.previousNode = null;\r\n                node.isWall = false;\r\n                node.isWeight = false;\r\n                if (node.isStart) {\r\n                    document.getElementById(`node-${node.row}-${node.col}`).className = 'node-start';\r\n                    continue;\r\n                }\r\n                if (node.isFinish) {\r\n                    document.getElementById(`node-${node.row}-${node.col}`).className = 'node-finish';\r\n                    continue;\r\n                }\r\n                document.getElementById(`node-${node.row}-${node.col}`).className = '';\r\n            }\r\n        }\r\n        this.setState({ grid: newGrid });\r\n    }\r\n\r\n    clearPath() {\r\n        const newGrid = this.state.grid;\r\n        for (let row of newGrid) {\r\n            for (let node of row) {\r\n                node.isStart = node.row === START_NODE_ROW && node.col === START_NODE_COL;\r\n                node.isFinish = node.row === FINISH_NODE_ROW && node.col === FINISH_NODE_COL;\r\n                node.distance = Infinity;\r\n                node.heuristic = 0;\r\n                node.isVisited = false;\r\n                node.previousNode = null;\r\n                if (node.isWall)\r\n                    continue;\r\n                if (node.isWeight) {\r\n                    document.getElementById(`node-${node.row}-${node.col}`).className = 'node-weight';\r\n                    continue;\r\n                }\r\n                node.isWall = false;\r\n                if (node.isStart) {\r\n                    document.getElementById(`node-${node.row}-${node.col}`).className = 'node-start';\r\n                    continue;\r\n                }\r\n                if (node.isFinish) {\r\n                    document.getElementById(`node-${node.row}-${node.col}`).className = 'node-finish';\r\n                    continue;\r\n                }\r\n                document.getElementById(`node-${node.row}-${node.col}`).className = '';\r\n            }\r\n        }\r\n        this.setState({ grid: newGrid });\r\n    }\r\n\r\n    handleMouseDown(row, col) {\r\n        if (row === START_NODE_ROW && col === START_NODE_COL) {\r\n            const newGrid = getNewGridWithStartToggled(this.state.grid, row, col);\r\n            this.setState({ grid: newGrid, mouseIsPressed: true, startIsSelected: true });\r\n            return;\r\n        }\r\n        if (row === FINISH_NODE_ROW && col === FINISH_NODE_COL) {\r\n            const newGrid = getNewGridWithFinishToggled(this.state.grid, row, col);\r\n            this.setState({ grid: newGrid, mouseIsPressed: true, finishIsSelected: true });\r\n            return;\r\n        }\r\n        if (document.getElementById(\"weightToggle\").checked === true) {\r\n            const newGrid = getNewGridWithWeightToggled(this.state.grid, row, col);\r\n            this.setState({ grid: newGrid, mouseIsPressed: true });\r\n            return;\r\n        }\r\n        const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n        this.setState({ grid: newGrid, mouseIsPressed: true });\r\n    }\r\n\r\n    handleMouseEnter(row, col) {\r\n        if (!this.state.mouseIsPressed) return;\r\n        if (this.state.startIsSelected) {\r\n            const newGrid = getNewGridWithStartToggled(this.state.grid, row, col);\r\n            this.setState({ grid: newGrid });\r\n            return;\r\n        }\r\n        if (this.state.finishIsSelected) {\r\n            const newGrid = getNewGridWithFinishToggled(this.state.grid, row, col);\r\n            this.setState({ grid: newGrid });\r\n            return;\r\n        }\r\n        if (document.getElementById(\"weightToggle\").checked === true) {\r\n            const newGrid = getNewGridWithWeightToggled(this.state.grid, row, col);\r\n            this.setState({ grid: newGrid });\r\n            return;\r\n        }\r\n        const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n        this.setState({ grid: newGrid });\r\n    }\r\n\r\n    handleMouseUp() {\r\n        this.setState({ mouseIsPressed: false, startIsSelected: false, finishIsSelected: false });\r\n    }\r\n\r\n    animateShortestPath(nodesInShortestPathOrder) {\r\n        for (let i = 0; i <= nodesInShortestPathOrder.length; i++) {\r\n            if (i === nodesInShortestPathOrder.length) {\r\n                setTimeout(() => {\r\n                    document.body.style.pointerEvents = \"all\";\r\n                    document.getElementById(\"navbar\").style.opacity = 1;\r\n                    document.getElementById(`node-${START_NODE_ROW}-${START_NODE_COL}`).className = 'node-start';\r\n                    document.getElementById(`node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`).className = 'node-finish';\r\n                }, 10 * (i + 1));\r\n                return;\r\n            }\r\n            setTimeout(() => {\r\n                const node = nodesInShortestPathOrder[i];\r\n                if (node.isWeight)\r\n                    document.getElementById(`node-${node.row}-${node.col}`).className = 'node-weight-shortest-path';\r\n                else\r\n                    document.getElementById(`node-${node.row}-${node.col}`).className = 'node-shortest-path';\r\n            }, 10 * (i + 1))\r\n        }\r\n    }\r\n\r\n    animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n        for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n            if (i === visitedNodesInOrder.length) {\r\n                setTimeout(() => {\r\n                    this.animateShortestPath(nodesInShortestPathOrder);\r\n                }, 10 * i);\r\n                return;\r\n            }\r\n            setTimeout(() => {\r\n                const node = visitedNodesInOrder[i];\r\n                if (node.isWeight)\r\n                    document.getElementById(`node-${node.row}-${node.col}`).className = 'node-weight-visited';\r\n                else\r\n                    document.getElementById(`node-${node.row}-${node.col}`).className = 'node-visited';\r\n            }, 10 * i)\r\n        }\r\n    }\r\n\r\n    visualizeDijkstraOrAstar(isDijkstra, isBFS) {\r\n        this.clearPath();\r\n        document.body.style.pointerEvents = \"none\";\r\n        document.getElementById(\"navbar\").style.opacity = 0.5;\r\n        const { grid } = this.state;\r\n        const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n        const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n        const visitedNodesInOrder = dijkstraANDastar(grid, startNode, finishNode, isDijkstra, isBFS);\r\n        const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n        this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    }\r\n\r\n    animateDFS(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n        for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n            if (i === visitedNodesInOrder.length) {\r\n                setTimeout(() => {\r\n                    this.animateShortestPath(nodesInShortestPathOrder);\r\n                }, 10 * i);\r\n                return;\r\n            }\r\n            setTimeout(() => {\r\n                const node = visitedNodesInOrder[i];\r\n                document.getElementById(`node-${node.row}-${node.col}`).className = 'node-visited';\r\n            }, 10 * i)\r\n        }\r\n    }\r\n\r\n    visualizeDFS() {\r\n        this.clearPath();\r\n        document.body.style.pointerEvents = \"none\";\r\n        document.getElementById(\"navbar\").style.opacity = 0.5;\r\n        const { grid } = this.state;\r\n        const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n        const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n        const visitedNodesInOrder = depthFirstSearch(grid, startNode, finishNode);\r\n        const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n        this.animateDFS(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    }\r\n\r\n    generateMaze() {\r\n        this.clearWeights();\r\n        document.body.style.pointerEvents = \"none\";\r\n        const items = document.getElementsByClassName(\"item\")\r\n        for (const item of items)\r\n            item.style.opacity = 0.5;\r\n        document.getElementById(\"status\").style.display = \"flex\";\r\n        document.getElementById(\"status\").style.opacity = 1;\r\n        const divisionWalls = [];\r\n        for (let j = 0; j < 50; j++)\r\n            divisionWalls.push([0, j]);\r\n        for (let k = 1; k < 20; k++) {\r\n            divisionWalls.push([k, 49]);\r\n            divisionWalls.push([k, 0]);\r\n        }\r\n        for (let l = 48; l >= 1; l--)\r\n            divisionWalls.push([19, l]);\r\n        recursiveDivisionMaze(2, 17, 2, 47, 0, divisionWalls);\r\n\r\n        for (let i = 0; i <= divisionWalls.length; i++) {\r\n            if (i === divisionWalls.length) {\r\n                setTimeout(() => {\r\n                    let newGrid = this.state.grid;\r\n                    for (let j = 0; j < divisionWalls.length; j++) {\r\n                        const row = divisionWalls[j][0];\r\n                        const col = divisionWalls[j][1];\r\n                        if (!newGrid[row][col].isWall && !newGrid[row][col].isStart && !newGrid[row][col].isFinish && !newGrid[row][col].isWeight) {\r\n                            newGrid[row][col].isWall = true;\r\n                        }\r\n                        document.body.style.pointerEvents = \"all\";\r\n                        const items = document.getElementsByClassName(\"item\")\r\n                        for (const item of items)\r\n                            item.style.opacity = 1;\r\n                        document.getElementById(\"status\").style.display = \"none\";\r\n                    }\r\n                    this.setState({ grid: newGrid });\r\n                }, 10.3 * (i - 1));\r\n                return;\r\n            }\r\n            setTimeout(() => {\r\n                const row = divisionWalls[i][0];\r\n                const col = divisionWalls[i][1];\r\n                const newGrid = this.state.grid;\r\n                if (!newGrid[row][col].isWall && !newGrid[row][col].isStart && !newGrid[row][col].isFinish) {\r\n                    document.getElementById(`node-${row}-${col}`).className = 'node-wall';\r\n                }\r\n            }, 10 * i);\r\n        }\r\n    }\r\n\r\n    render() {\r\n        const { grid, mouseIsPressed } = this.state;\r\n\r\n        return (\r\n            <>\r\n                <div className=\"ui stackable menu\" id=\"navbar\">\r\n                    <div className=\"item\" style={{ color: \"white\", backgroundColor: \"#1A1A1D\" }}>\r\n                        <i class=\"road icon\"></i>Pathfinding Visualizer\r\n                    </div>\r\n                    <button className=\"item\" onClick={() => { this.visualizeDijkstraOrAstar(true, false) }} style={{ border: \"none\" }}>Visualize Dijkstra</button>\r\n                    <button className=\"item\" onClick={() => { this.visualizeDijkstraOrAstar(false, false) }} style={{ border: \"none\" }}>Visualize A*</button>\r\n                    <button className=\"item\" onClick={() => { this.visualizeDijkstraOrAstar(true, true) }} style={{ border: \"none\" }}>Visualize BFS</button>\r\n                    <button className=\"item\" onClick={() => { this.visualizeDFS() }} style={{ border: \"none\" }}>Visualize DFS</button>\r\n                    <button className=\"item\" onClick={() => { this.clearWeights() }} style={{ border: \"none\" }}>Clear Weights</button>\r\n                    <button className=\"item\" onClick={() => { this.clearPath() }} style={{ border: \"none\" }}>Clear Path</button>\r\n                    <button className=\"item\" onClick={() => { this.clearBoard() }} style={{ border: \"none\" }}>Refresh</button>\r\n                    <div className=\"item\">\r\n                        <div className=\"ui toggle checkbox\">\r\n                            <input type=\"checkbox\" name=\"public\" id=\"weightToggle\" />\r\n                            <label>Drag to add weights</label>\r\n                        </div>\r\n                    </div>\r\n                    <button className=\"item\" onClick={() => { this.generateMaze() }} style={{ border: \"none\" }}>Generate Maze</button>\r\n                    <button id=\"status\" style={{ border: \"none\", display: \"none\", alignItems: \"center\", backgroundColor: \"black\", color: \"white\", position: \"relative\" }}><div class=\"loader\"></div>Loading Maze .. Please Wait!</button>\r\n                </div>\r\n                <table>\r\n                    <tbody>\r\n                        {grid.map((row, rowIdx) => {\r\n                            return <tr key={rowIdx}>\r\n                                {row.map((node, nodeIdx) => {\r\n                                    const { row, col, isStart, isFinish, isWall, isWeight } = node;\r\n                                    return (\r\n                                        <Node\r\n                                            key={nodeIdx}\r\n                                            row={row}\r\n                                            col={col}\r\n                                            isStart={isStart}\r\n                                            isFinish={isFinish}\r\n                                            isWall={isWall}\r\n                                            isWeight={isWeight}\r\n                                            mouseIsPressed={mouseIsPressed}\r\n                                            onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                                            onMouseEnter={(row, col) => this.handleMouseEnter(row, col)}\r\n                                            onMouseUp={() => this.handleMouseUp()}\r\n                                            nodeSize={this.state.nodeSize}\r\n                                        />\r\n                                    )\r\n                                })}\r\n                            </tr>\r\n                        })}\r\n                    </tbody>\r\n                </table>\r\n                <div className=\"ui left labeled button\" style={{ fontSize: \"0.8rem\", marginTop: \"1rem\", marginLeft: \"0.5rem\" }}>\r\n                    <a className=\"ui basic label\" style={{ backgroundColor: \"black\", color: \"white\" }} href=\"https://github.com/RishabhSood\">\r\n                        <i className=\"github icon\"></i> RishabhSood\r\n                    </a>\r\n                    <a className=\"ui icon button\" href=\"https://github.com/RishabhSood/pathFindingVisualizer\">\r\n                        <i className=\"fork icon\"></i>\r\n                    </a>\r\n                </div>\r\n                <div className=\"ui left labeled button\" style={{ fontSize: \"0.8rem\" }}>\r\n                    <div className=\"ui basic label\" style={{ backgroundColor: \"#0072b1\", color: \"white\" }}>\r\n                        <i className=\"linkedin icon\"></i> RishabhSood\r\n                    </div>\r\n                    <a className=\"ui icon button\" href=\"https://www.linkedin.com/in/rishabh-sood-6312931a1/\">\r\n                        <i className=\"user plus icon\"></i>\r\n                    </a>\r\n                </div>\r\n            </>\r\n        );\r\n    }\r\n}\r\nconst getInitialGrid = () => {\r\n    const grid = [];\r\n    for (let row = 0; row < 20; row++) {\r\n        const currentRow = [];\r\n        for (let col = 0; col < 50; col++) {\r\n            currentRow.push(createNode(col, row));\r\n        }\r\n        grid.push(currentRow);\r\n    }\r\n    return grid;\r\n};\r\n\r\nconst createNode = (col, row) => {\r\n    return {\r\n        col,\r\n        row,\r\n        isStart: row === START_NODE_ROW && col === START_NODE_COL,\r\n        isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\r\n        distance: Infinity,\r\n        heuristic: 0,\r\n        isVisited: false,\r\n        isWall: false,\r\n        isWeight: false,\r\n        previousNode: null,\r\n    };\r\n};\r\n\r\nconst getNewGridWithWallToggled = (grid, row, col) => {\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    if (node.isStart || node.isFinish || node.isWeight)\r\n        return newGrid;\r\n    const newNode = {\r\n        ...node,\r\n        isWall: !node.isWall,\r\n    };\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n};\r\n\r\nconst getNewGridWithWeightToggled = (grid, row, col) => {\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    if (node.isStart || node.isFinish || node.isWall)\r\n        return newGrid;\r\n    const newNode = {\r\n        ...node,\r\n        isWeight: !node.isWeight,\r\n    };\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n};\r\n\r\nconst getNewGridWithStartToggled = (grid, row, col) => {\r\n    const newGrid = grid.slice();\r\n    let previousStart = newGrid[START_NODE_ROW][START_NODE_COL];\r\n    const change = {\r\n        ...previousStart,\r\n        isStart: false,\r\n    }\r\n    newGrid[START_NODE_ROW][START_NODE_COL] = change;\r\n    START_NODE_ROW = row;\r\n    START_NODE_COL = col;\r\n    const node = newGrid[row][col];\r\n    const newNode = {\r\n        ...node,\r\n        isWall: false,\r\n        isWeight: false,\r\n        isStart: true,\r\n    };\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n};\r\n\r\nconst getNewGridWithFinishToggled = (grid, row, col) => {\r\n    const newGrid = grid.slice();\r\n    let previousFinish = newGrid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    const change = {\r\n        ...previousFinish,\r\n        isFinish: false,\r\n    }\r\n    newGrid[FINISH_NODE_ROW][FINISH_NODE_COL] = change;\r\n    FINISH_NODE_ROW = row;\r\n    FINISH_NODE_COL = col;\r\n    const node = newGrid[row][col];\r\n    const newNode = {\r\n        ...node,\r\n        isWall: false,\r\n        isWeight: false,\r\n        isFinish: true,\r\n    };\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n};","import React from 'react';\r\nimport PathFindingVisualizer from './PathFindingVisualizer/PathFindingVisualizer';\r\n\r\nconst App = () => {\r\n    return (\r\n        <PathFindingVisualizer />\r\n    );\r\n}\r\n\r\nexport default App;","import React from 'react';\r\nimport ReactDom from 'react-dom';\r\nimport App from './App';\r\n\r\nReactDom.render(<App />, document.querySelector(\"#root\"));"],"sourceRoot":""}